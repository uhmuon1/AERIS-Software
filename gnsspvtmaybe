#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "pico/stdlib.h"
#include "hardware/i2c.h"

#define GNSS_ADDR 0x42
#define UBX_SYNC1 0xB5
#define UBX_SYNC2 0x62
#define NAV_CLASS 0x01
#define NAV_PVT_ID 0x07
#define UPDATE_RATE_MS 40  // 25Hz = 40ms per update
#define DISPLAY_UPDATE_MS 200  // Update display every 200ms to avoid flooding serial

typedef struct {
    // Time data
    uint16_t year;
    uint8_t month;
    uint8_t day;
    uint8_t hour;
    uint8_t min;
    uint8_t sec;
    
    // Position data
    int32_t lon;    
    int32_t lat;    
    int32_t height; 
    int32_t hMSL;   
    
    // Velocity data
    int32_t velN;   
    int32_t velE;   
    int32_t velD;   
    uint32_t gSpeed;
    
    // Status data
    uint8_t numSV;  
    uint8_t fixType;
    
    // Message counter
    uint32_t msg_count;
} ubx_pvt_data_t;

bool read_byte(i2c_inst_t *i2c, uint8_t *byte) {
    return (i2c_read_blocking(i2c, GNSS_ADDR, byte, 1, false) == 1);
}

bool wait_for_sync(i2c_inst_t *i2c) {
    uint8_t byte;
    uint32_t start_time = to_ms_since_boot(get_absolute_time());
    
    while ((to_ms_since_boot(get_absolute_time()) - start_time) < UPDATE_RATE_MS) {
        if (!read_byte(i2c, &byte)) return false;
        if (byte == UBX_SYNC1) {
            if (!read_byte(i2c, &byte)) return false;
            if (byte == UBX_SYNC2) return true;
        }
    }
    return false;
}

bool read_ubx_message(i2c_inst_t *i2c, ubx_pvt_data_t *data) {
    uint8_t header[4];
    uint8_t checksum[2];
    uint8_t pvt_data[92];
    
    if (!wait_for_sync(i2c)) {
        return false;
    }
    
    // Read message class and ID
    if (i2c_read_blocking(i2c, GNSS_ADDR, header, 4, false) != 4) {
        return false;
    }
    
    if (header[0] != NAV_CLASS || header[1] != NAV_PVT_ID) {
        return false;
    }
    
    uint16_t length = header[2] | (header[3] << 8);
    if (length != 92) {
        return false;
    }
    
    // Read PVT data
    if (i2c_read_blocking(i2c, GNSS_ADDR, pvt_data, length, false) != length) {
        return false;
    }
    
    // Read checksum
    if (i2c_read_blocking(i2c, GNSS_ADDR, checksum, 2, false) != 2) {
        return false;
    }
    
    // Parse data
    data->year = pvt_data[4] | (pvt_data[5] << 8);
    data->month = pvt_data[6];
    data->day = pvt_data[7];
    data->hour = pvt_data[8];
    data->min = pvt_data[9];
    data->sec = pvt_data[10];
    
    data->fixType = pvt_data[20];
    data->numSV = pvt_data[23];
    
    data->lon = pvt_data[24] | (pvt_data[25] << 8) | (pvt_data[26] << 16) | (pvt_data[27] << 24);
    data->lat = pvt_data[28] | (pvt_data[29] << 8) | (pvt_data[30] << 16) | (pvt_data[31] << 24);
    data->height = pvt_data[32] | (pvt_data[33] << 8) | (pvt_data[34] << 16) | (pvt_data[35] << 24);
    data->hMSL = pvt_data[36] | (pvt_data[37] << 8) | (pvt_data[38] << 16) | (pvt_data[39] << 24);
    
    data->velN = pvt_data[48] | (pvt_data[49] << 8) | (pvt_data[50] << 16) | (pvt_data[51] << 24);
    data->velE = pvt_data[52] | (pvt_data[53] << 8) | (pvt_data[54] << 16) | (pvt_data[55] << 24);
    data->velD = pvt_data[56] | (pvt_data[57] << 8) | (pvt_data[58] << 16) | (pvt_data[59] << 24);
    data->gSpeed = pvt_data[60] | (pvt_data[61] << 8) | (pvt_data[62] << 16) | (pvt_data[63] << 24);
    
    data->msg_count++;
    return true;
}

const char* get_fix_type_str(uint8_t fix_type) {
    switch(fix_type) {
        case 0: return "No fix";
        case 1: return "Dead reckoning";
        case 2: return "2D fix";
        case 3: return "3D fix";
        case 4: return "GNSS + Dead reckoning";
        default: return "Unknown";
    }
}

int main() {
    stdio_init_all();
    sleep_ms(2000);
    
    printf("\nStarting UBX Message Reader (25Hz)\n");
    printf("--------------------------------\n");
    
    i2c_init(i2c_default, 400000);  // Increased to 400kHz for faster data transfer
    gpio_set_function(PICO_DEFAULT_I2C_SDA_PIN, GPIO_FUNC_I2C);
    gpio_set_function(PICO_DEFAULT_I2C_SCL_PIN, GPIO_FUNC_I2C);
    gpio_pull_up(PICO_DEFAULT_I2C_SDA_PIN);
    gpio_pull_up(PICO_DEFAULT_I2C_SCL_PIN);
    
    printf("I2C Initialized at 400kHz\n\n");
    
    ubx_pvt_data_t pvt_data = {0};
    uint32_t last_display_update = 0;
    uint32_t messages_per_second = 0;
    uint32_t last_msg_count = 0;
    uint32_t last_rate_check = 0;
    
    while (true) {
        if (read_ubx_message(i2c_default, &pvt_data)) {
            uint32_t current_time = to_ms_since_boot(get_absolute_time());
            
            // Update message rate calculation every second
            if (current_time - last_rate_check >= 1000) {
                messages_per_second = pvt_data.msg_count - last_msg_count;
                last_msg_count = pvt_data.msg_count;
                last_rate_check = current_time;
            }
            
            // Update display every DISPLAY_UPDATE_MS
            if (current_time - last_display_update >= DISPLAY_UPDATE_MS) {
                printf("\033[2J\033[H");  // Clear screen
                
                printf("Messages received: %lu (Rate: %lu Hz)\n\n", 
                       pvt_data.msg_count, messages_per_second);
                
                printf("Time: %02d:%02d:%02d %02d/%02d/%04d\n", 
                       pvt_data.hour, pvt_data.min, pvt_data.sec,
                       pvt_data.day, pvt_data.month, pvt_data.year);
                
                printf("\nPosition:\n");
                printf("  Lat: %.7f°, Lon: %.7f°\n", 
                       pvt_data.lat * 1e-7, pvt_data.lon * 1e-7);
                printf("  Height: %.2fm (MSL: %.2fm)\n", 
                       pvt_data.height / 1000.0, pvt_data.hMSL / 1000.0);
                
                printf("\nVelocity:\n");
                printf("  N: %.2f m/s\n", pvt_data.velN / 100.0);
                printf("  E: %.2f m/s\n", pvt_data.velE / 100.0);
                printf("  D: %.2f m/s\n", pvt_data.velD / 100.0);
                printf("  Ground: %.2f m/s\n", pvt_data.gSpeed / 100.0);
                
                printf("\nStatus:\n");
                printf("  Fix: %s\n", get_fix_type_str(pvt_data.fixType));
                printf("  Satellites: %d\n", pvt_data.numSV);
                
                last_display_update = current_time;
            }
        }
    }
    
    return 0;
}
