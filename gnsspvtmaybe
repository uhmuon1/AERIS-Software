#include <stdio.h>
#include <string.h>
#include "pico/stdlib.h"
#include "hardware/i2c.h"

#define GNSS_ADDR 0x42
#define UBX_SYNC_1 0xB5
#define UBX_SYNC_2 0x62
#define MAX_PAYLOAD_SIZE 100

// UBX Protocol specific data structure
typedef struct {
    int32_t ecefX;      // cm
    int32_t ecefY;      // cm
    int32_t ecefZ;      // cm
    int32_t velX;       // cm/s
    int32_t velY;       // cm/s
    int32_t velZ;       // cm/s
    uint8_t numSV;      // Number of satellites
    uint8_t fixType;    // Fix type
} ubx_data_t;

// Configuration messages
const uint8_t ubx_config_data[] = {
    0xB5, 0x62,           // Sync chars
    0x06, 0x00,           // CFG-PRT message
    0x14, 0x00,           // Length (20 bytes)
    0x00,                 // Port ID (I2C)
    0x00,                 // Reserved
    0x00, 0x00,           // TX ready
    0x84, 0x00, 0x00, 0x00, // Mode
    0x00, 0x00, 0x00, 0x00, // Baudrate (not used for I2C)
    0x03, 0x00,           // inProtoMask (UBX-03)
    0x03, 0x00,           // outProtoMask (UBX-03)
    0x00, 0x00,           // Flags
    0x00, 0x00,           // Reserved
    0x86, 0x8C            // Checksum
};

// Save configuration
const uint8_t save_config[] = {
    0xB5, 0x62,           // Sync chars
    0x06, 0x09,           // CFG-CFG message
    0x0D, 0x00,           // Length
    0x00, 0x00, 0x00, 0x00, // Clear mask
    0xFF, 0xFF, 0x00, 0x00, // Save mask
    0x00, 0x00, 0x00, 0x00, // Load mask
    0x01,                 // Device mask
    0x1B, 0xA5            // Checksum
};

// Function to send configuration
bool send_config_message(i2c_inst_t *i2c, const uint8_t *message, size_t length) {
    int bytes_written = i2c_write_blocking(i2c, GNSS_ADDR, message, length, false);
    return (bytes_written == length);
}

// Calculate checksum for UBX messages
void calculate_checksum(uint8_t *buffer, size_t length, uint8_t *ck_a, uint8_t *ck_b) {
    *ck_a = 0;
    *ck_b = 0;
    for(size_t i = 0; i < length; i++) {
        *ck_a += buffer[i];
        *ck_b += *ck_a;
    }
}

// Read a UBX message
bool read_ubx_message(i2c_inst_t *i2c, ubx_data_t *data) {
    uint8_t byte;
    uint8_t buffer[MAX_PAYLOAD_SIZE];
    
    // Look for sync chars
    while(1) {
        if (i2c_read_blocking(i2c, GNSS_ADDR, &byte, 1, false) != 1) return false;
        if (byte != UBX_SYNC_1) continue;
        
        if (i2c_read_blocking(i2c, GNSS_ADDR, &byte, 1, false) != 1) return false;
        if (byte == UBX_SYNC_2) break;
    }
    
    // Read header
    uint8_t header[4];
    if (i2c_read_blocking(i2c, GNSS_ADDR, header, 4, false) != 4) return false;
    
    // Check message class and ID (NAV-PVT)
    if (header[0] != 0x01 || header[1] != 0x07) return false;
    
    // Get payload length
    uint16_t length = header[2] | (header[3] << 8);
    if (length > MAX_PAYLOAD_SIZE) return false;
    
    // Read payload
    if (i2c_read_blocking(i2c, GNSS_ADDR, buffer, length, false) != length) return false;
    
    // Read checksum
    uint8_t checksum[2];
    if (i2c_read_blocking(i2c, GNSS_ADDR, checksum, 2, false) != 2) return false;
    
    // Verify checksum
    uint8_t ck_a, ck_b;
    calculate_checksum(header, 4 + length, &ck_a, &ck_b);
    if (ck_a != checksum[0] || ck_b != checksum[1]) return false;
    
    // Parse PVT data (simplified - adjust offsets based on your firmware version)
    data->ecefX = buffer[0] | (buffer[1] << 8) | (buffer[2] << 16) | (buffer[3] << 24);
    data->ecefY = buffer[4] | (buffer[5] << 8) | (buffer[6] << 16) | (buffer[7] << 24);
    data->ecefZ = buffer[8] | (buffer[9] << 8) | (buffer[10] << 16) | (buffer[11] << 24);
    data->velX = buffer[12] | (buffer[13] << 8) | (buffer[14] << 16) | (buffer[15] << 24);
    data->velY = buffer[16] | (buffer[17] << 8) | (buffer[18] << 16) | (buffer[19] << 24);
    data->velZ = buffer[20] | (buffer[21] << 8) | (buffer[22] << 16) | (buffer[23] << 24);
    data->numSV = buffer[24];
    data->fixType = buffer[25];
    
    return true;
}

int main() {
    stdio_init_all();
    sleep_ms(2000);  // Wait for serial to initialize
    
    printf("Starting UBX-03 GPS Reader\n");
    
    // Initialize I2C
    i2c_init(i2c_default, 100 * 1000);
    gpio_set_function(PICO_DEFAULT_I2C_SDA_PIN, GPIO_FUNC_I2C);
    gpio_set_function(PICO_DEFAULT_I2C_SCL_PIN, GPIO_FUNC_I2C);
    gpio_pull_up(PICO_DEFAULT_I2C_SDA_PIN);
    gpio_pull_up(PICO_DEFAULT_I2C_SCL_PIN);
    
    // Configure for UBX-03
    printf("Configuring for UBX-03...\n");
    if (!send_config_message(i2c_default, ubx_config_data, sizeof(ubx_config_data))) {
        printf("Failed to send UBX configuration\n");
        return 1;
    }
    
    sleep_ms(100);
    
    // Save configuration
    printf("Saving configuration...\n");
    if (!send_config_message(i2c_default, save_config, sizeof(save_config))) {
        printf("Failed to save configuration\n");
        return 1;
    }
    
    printf("Configuration complete. Starting to read UBX messages...\n");
    
    ubx_data_t ubx_data;
    
    while (true) {
        if (read_ubx_message(i2c_default, &ubx_data)) {
            printf("\nUBX Data:\n");
            printf("Position (ECEF): X=%d cm, Y=%d cm, Z=%d cm\n", 
                   ubx_data.ecefX, ubx_data.ecefY, ubx_data.ecefZ);
            printf("Velocity: X=%d cm/s, Y=%d cm/s, Z=%d cm/s\n", 
                   ubx_data.velX, ubx_data.velY, ubx_data.velZ);
            printf("Satellites: %d\n", ubx_data.numSV);
            printf("Fix Type: %d\n", ubx_data.fixType);
        } else {
            printf("Failed to read UBX message\n");
        }
        
        sleep_ms(1000);
    }
    
    return 0;
}
